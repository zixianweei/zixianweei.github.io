[{"categories":["编程语言"],"content":"通常情况下，操作符new用于动态分类内存；并且所分配内存的生命周期将不受作用域管理1。与malloc()方法不同，操作符new会做两件事：分配内存；初始化对象。而placement new则是一种特殊的动态内存方法，其能够在已分配的内存空间上创建对象。因此，placement new只做了一件事：初始化对象。 Creates and initializes objects with dynamic storage duration, that is, objects whose lifetime is not necessarily limited by the scope in which they were created. If placement-params are provided, they are passed to the allocation function as additional arguments. Such allocation functions are known as placement new, after the standard allocation function void* operator new(std::size_t, void*), which simply returns its second argument unchanged. This is used to construct objects in allcated storage. ","date":"2023-09-08","objectID":"/placement-new/:0:0","tags":["C/C++"],"title":"C++中的placement new","uri":"/placement-new/"},{"categories":["编程语言"],"content":"使用方式 #include \u003ciostream\u003e class MyClass { public: MyClass() { std::cout \u003c\u003c \"MyClass::MyClass\\n\"; } ~MyClass() { std::cout \u003c\u003c \"MyClass::~MyClass\\n\"; } MyClass(const MyClass\u0026) = delete; MyClass\u0026 operator=(const MyClass\u0026) = delete; MyClass(MyClass\u0026\u0026) = delete; MyClass\u0026 operator=(MyClass\u0026\u0026) = delete; private: int m1; double m2; }; int main() { { char buf[sizeof(MyClass)]; void* p = buf; MyClass* o = new (p) MyClass(); // placement new o-\u003e~MyClass(); // Explicitly call the destructor for the placed object. } { MyClass* o = new MyClass(); std::cout \u003c\u003c \"o address = \" \u003c\u003c o \u003c\u003c \"\\n\"; o-\u003e~MyClass(); o = new (o) MyClass(); // placement new std::cout \u003c\u003c \"o address = \" \u003c\u003c o \u003c\u003c \"\\n\"; delete o; } return 0; } 上方是一段使用placement new的场景：在栈上申请一段内存后，将这段内存的地址作为参数传递给操作符new。此外，对象的生命周期由用户负责：离开作用域时，系统会自动回收buf；在此之前，需要显式调用对象的析构函数。 ","date":"2023-09-08","objectID":"/placement-new/:1:0","tags":["C/C++"],"title":"C++中的placement new","uri":"/placement-new/"},{"categories":["编程语言"],"content":"使用场景 placement new能够在已分配内存上直接构造对象，省去了内存的分配的过程，可以重复利用已分配空间。但总的来说，并不推荐使用placement new，原因如下2： placement new需要用户自行保证已分配的内存空间能够放置对象，编译器和运行时都不会对空间是否足够进行检查。 已分配空间可能存在对齐问题：虽然理论上已分配空间可以放置对象，但由于内存对齐，实际占用的空间会更大。 总的来说，编译器和运行时不会检查placement new是否正确完成，需要用户自行考虑空间大小内存对齐等问题。不管怎样，placement new不要随意使用，除非迫不得已；如果想要重复利用已分配内存空间，用户应当选择使用内存池管理内存而不使用placement new。 cppreference.com - new expression ↩︎ isocpp - FAQ:Destructors ↩︎ ","date":"2023-09-08","objectID":"/placement-new/:2:0","tags":["C/C++"],"title":"C++中的placement new","uri":"/placement-new/"},{"categories":null,"content":"Hi~，欢迎来到我的小破站。这里记录了我学习C++和图形图像等知识的笔记。此外，还有一些与生活相关的奇怪想法。 如果有啥想说的话可以在最下方评论，我会尽快回复。也可以通过邮件联系到我：zixianwei@foxmail.com。 ","date":"2020-12-21","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"参与的开源项目 OpenCV: fix compilation error on Windows ARM, use vaddq_f32 instead of += #24043 ","date":"2020-12-21","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"目前使用的设备 MacBook Pro 13 NUC8i5BEK CPU Intel Core i5-1038NG7 Intel Core i5-8259U 内存 LPDDR4 3733MHz 8GB$\\times$2 DDR4 2666MHz 8GB$\\times$2 ","date":"2020-12-21","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"}]